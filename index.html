<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Custom LLM Build Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#fff; --ink:#0b1020; --muted:#6b7280; --card:#fff; --line:#e5e7eb }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--ink)}

    /* Layout */
    .wrap{min-height:100vh; padding:16px; display:flex; flex-direction:column; gap:16px}

    /* Grid: stack on mobile; 2 centered columns (560px max) on desktop */
    .grid{display:grid; gap:16px; grid-template-columns:1fr}
    @media(min-width:900px){
      .grid{
        grid-template-columns: repeat(2, minmax(0, 560px));
        justify-content: center;   /* center both columns as a unit */
        justify-items: stretch;
      }
    }
    .grid.single{grid-template-columns:1fr; justify-items:center} /* When traits minimized: center avatar */

    /* Cards / Text */
    .card{background:var(--card); border:none; border-radius:24px; box-shadow:0 8px 24px rgba(0,0,0,.05); padding:20px; width:100%}
    .h2{font-size:20px; font-weight:700; margin:0 0 6px}
    .muted{color:var(--muted)}
    .stack{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .tiny{font-size:12px; color:var(--muted)}
    .hidden{display:none}

    /* Avatar */
    .avatarCard{max-width:560px; width:100%}
    .avatarWrap{display:flex; flex-direction:column; align-items:center; user-select:none; width:100%}
  .avatarWrap svg{width:64%; height:auto; max-width:448px; display:block; margin-left:auto; margin-right:auto;}

    /* Traits (match avatar width on desktop) */
    .traitsCard{max-width:560px; width:100%}

    /* Trait rows */
    .row{display:flex; align-items:center; gap:12px; padding:6px 0; flex-wrap:wrap}
    .label{flex:1; font-size:14px; color:#374151; min-width:140px}
    .slider{flex: 0 0 50%; }
    @media(max-width:600px){
      .row{flex-direction:column; align-items:stretch}
      .label{min-width:0}
      .slider{width:100%}
    }

    /* Chat */
    .chat{display:flex; flex-direction:column; gap:10px; min-height:220px; margin:10px 0; max-height:50vh; overflow-y:auto}
    .chat { min-height:180px; max-height:220px; overflow-y:auto; }

    .bubble{max-width:75%; padding:10px 14px; border-radius:16px; line-height:1.45; white-space:pre-wrap; word-wrap:break-word}
    .user{align-self:flex-end; background:#f3f4f6}
    .assistant{align-self:flex-start; background:#fff; border:1px solid var(--line)}
    @media(max-width:600px){ .bubble{max-width:100%} }

    /* Put near your other CSS */
    .chatContainer{ margin-inline:auto; }  /* center it */
    @media(min-width:900px){
      .chatContainer{ max-width: calc(560px * 2 + 16px); }   /* 2 cols (560) + 16px gap = 1136px */
    }

    /* Input row — compact, single-line, proportional */
    .inputRow{display:flex; gap:8px; align-items:center; flex-wrap:nowrap}
    .inputRow input[type="text"]{
      flex:1;
      padding:8px 12px;
      border:1px solid var(--line);
      border-radius:999px;
      font-size:15px;
      line-height:1.4;
      min-width:0;
      height:38px;
    }
    .btn{
      padding:8px 14px;
      border:none;
      background:#111;
      color:#fff;
      border-radius:999px;
      cursor:pointer;
      white-space:nowrap;
      height:38px;
    }
    .btn.sec{background:#f3f4f6; color:#111; border:1px solid var(--line)}

    /* Card header + minimize button */
    .cardHeader{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
    .btn.tiny{height:auto; padding:6px 10px; font-size:13px; line-height:1; border-radius:999px}

    /* Floating restore button (top-right) */
    .fab{
      position:fixed;
      right:16px;
      top:16px;
      z-index:1000;
      box-shadow:0 8px 24px rgba(0,0,0,.15);
      padding:10px 14px;
      border-radius:999px;
    }

    /* increase size of floating restore button */
    .avatarCard{ position: relative; max-width:560px; width:100%; }
    #restoreTraits{
      position: absolute;
      top: 15%;
      right: 30px;
      transform: translateY(-50%);
      font-size: 28px;
      width: 76px;
      height: 76px;
      border-radius: 50%;
    }
    #restoreTraits{ font-size:28px; width:50px; height:50px; }
    .avatarWrap svg { width: 80% !important; height: auto; }
  </style>
</head>
<body>
<div class="wrap">
  <!-- <div class="stack">
    <div class="h2">Parameterized LLM Assistant</div>
    <div class="tiny">Demo</div>
  </div> -->

  <!-- Avatar + Traits -->
  <div class="grid" id="cardsGrid">
    <!-- Avatar -->
    <div class="card avatarCard" style="text-align:center">
      <div id="avatar" class="avatarWrap"></div>
      <button id="restoreTraits" class="btn sec iconBtn hidden" title="Show Traits">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 9V3h6M21 9V3h-6M3 15v6h6M21 15v6h-6"/>
        </svg>
      </button>
    </div>

    <!-- Traits (minimizable) -->
    <div class="card traitsCard" id="traitsCard">
      <div class="cardHeader">
        <div class="h2" style="margin:0">Traits</div>
        <!-- Minimize the entire card -->
        <button id="minimizeTraits" class="btn sec tiny" title="Minimize">━</button>
      </div>
      <div id="traitsContent">
        <div class="row">
          <div class="label">Logic (intuitive ↔ rational)</div>
          <input id="logic" class="slider" type="range" min="0" max="5" step="1">
        </div>
        <div class="row">
          <div class="label">Empathy (cool ↔ warm)</div>
          <input id="empathy" class="slider" type="range" min="0" max="5" step="1">
        </div>
        <div class="row">
          <div class="label">Playfulness (serious ↔ fun)</div>
          <input id="play" class="slider" type="range" min="0" max="5" step="1">
        </div>
        <div class="row">
          <div class="label">Confidence (reserved ↔ bold)</div>
          <input id="conf" class="slider" type="range" min="0" max="5" step="1">
        </div>
      </div>
    </div>
  </div>

  <!-- Chat -->
  <div class="card chatContainer" style="flex:1; position:relative">
    <div class="h2" style="display:flex; justify-content:space-between; align-items:center;">
      Chat
      <button class="btn sec iconBtn" id="clear" title="Clear Chat">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 512 512" fill="currentColor">
          <path d="M432 32H336l-16-32H192l-16 32H96v64h336V32zM112 128v352c0 17.7 14.3 32 32 32h224c17.7 0 32-14.3 32-32V128H112zm96 64h32v224h-32V192zm64 0h32v224h-32V192z"/>
        </svg>
      </button>
    </div>

    <div id="chat" class="chat"></div>

    <div class="inputRow">
      <input id="prompt" type="text" placeholder="Say something…" />
      <button class="btn" id="send">▶</button>
    </div>
  </div>

  <!-- Floating restore button (only visible when traits are minimized) -->
  <button id="restoreTraits" class="btn sec fab hidden" title="Show Traits">⚙</button>
</div>

<script>
  // --------- tiny state helpers ----------
  const LS = { traits:"glow_traits_local", msgs:"glow_msgs_local", traitsMin:"glow_traits_minimized" };
  const $ = (q) => document.querySelector(q);
  const save = (k,v)=>localStorage.setItem(k, JSON.stringify(v));
  const load = (k,f)=>{try{const r=localStorage.getItem(k);return r?JSON.parse(r):f}catch{return f}};

  // --------- minimize/restore Traits (persisted) ----------
  const traitsCard = $("#traitsCard");
  const restoreTraits = $("#restoreTraits");
  const grid = $("#cardsGrid");
  const minimizeBtn = $("#minimizeTraits");
  let minimized = load(LS.traitsMin, false);

  function applyMinState(){
    if(minimized){
      traitsCard.classList.add("hidden");
      restoreTraits.classList.remove("hidden");
      grid.classList.add("single");   // center avatar when only one column
    }else{
      traitsCard.classList.remove("hidden");
      restoreTraits.classList.add("hidden");
      grid.classList.remove("single");
    }
  }
  minimizeBtn.addEventListener("click", ()=>{
    minimized = true;
    applyMinState();
    save(LS.traitsMin, minimized);
  });
  restoreTraits.addEventListener("click", ()=>{
    minimized = false;
    applyMinState();
    save(LS.traitsMin, minimized);
  });
  applyMinState();

  // --------- avatar math ----------
  const MAX = 5;
  const clamp=(n,min=0,max=MAX)=>Math.max(min,Math.min(max,n));

  function seedFromTraits(t){
    // Empathy inverted: higher = warmer
    const empathyW = clamp(t.empathy)/MAX; // 0 = cool, 5 = warm
    const rational = clamp(t.logic)/MAX;
    const conf = clamp(t.confidence)/MAX;
    const playful = clamp(t.playfulness)/MAX;

    // Hue: 210 (cool blue) → 30 (warm orange) as empathy increases
    const hue = Math.round(210 * (1 - empathyW) + 30 * empathyW);

    // Keep saturation tied to playfulness; make warmer slightly darker
    const sat = Math.round(50 + playful * 45);
    const lig = Math.round(50 + playful * 12 - empathyW * 5);

    return {
      fill: `hsl(${hue}, ${sat}%, ${lig}%)`,
      r: Math.min(90, Math.round(90 - rational * 82)),
      eyes: rational > 0.66 ? "squares" : rational > 0.33 ? "ovals" : "dots",
      smile: conf >= 0.34,
      smileAmt: 4 + conf * 16,
      smileLift: conf * 8,
      glow: 8 + Math.round(conf * 12),
    };
  }

  function renderAvatar(t){
    const s = seedFromTraits(t);
    const id = Math.random().toString(36).slice(2);

    const eye = (x) =>
      s.eyes==="squares"
        ? `<rect x="${x-9}" y="95.8" width="18" height="10.8" rx="2" fill="#0b1020"/>` // y=92+3.8, height=18*0.6=10.8
        : s.eyes==="ovals"
        ? `<ellipse cx="${x}" cy="101" rx="9" ry="7.5" fill="#0b1020"/>`
        : `<circle cx="${x}" cy="101" r="7.5" fill="#0b1020"/>`;

    const mouth = s.smile
      ? `M80 ${145 - s.smileLift} Q120 ${145 + s.smileAmt - s.smileLift} 160 ${145 - s.smileLift}`
      : `M92 142 H148`;

    // Always use a circle for the avatar background
    $("#avatar").innerHTML = `
  <svg width="230" height="230" viewBox="0 0 240 240" role="img" preserveAspectRatio="xMidYMid meet">
        <defs>
          <linearGradient id="ov-${id}" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="white" stop-opacity="0.12"/>
            <stop offset="100%" stop-color="white" stop-opacity="0.02"/>
          </linearGradient>
          <filter id="f-${id}" x="-40%" y="-40%" width="180%" height="180%">
            <feGaussianBlur stdDeviation="${s.glow}" result="b"/>
            <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
          </filter>
        </defs>
        <!-- Scale everything to 80% and re-center -->
        <g transform="translate(24,24) scale(0.8)">
          <circle cx="120" cy="120" r="90" fill="${s.fill}" filter="url(#f-${id})"/>
          <circle cx="120" cy="120" r="90" fill="url(#ov-${id})" pointer-events="none"/>
          ${eye(90)} ${eye(150)}
          <path d="${mouth}" stroke="#0b1020" stroke-width="10" stroke-linecap="round" fill="none"/>
        </g>
      </svg>
    `;
  }

  // --------- init traits + wire sliders ----------
  const traits = load(LS.traits, { empathy:3, logic:2, playfulness:3, confidence:3 });
  $("#empathy").value = traits.empathy;
  $("#logic").value   = traits.logic;
  $("#play").value    = traits.playfulness;
  $("#conf").value    = traits.confidence;
  renderAvatar(traits);

  function bindSlider(id, k){
    const el = $(id);
    el.addEventListener("input", e=>{
      traits[k] = parseInt(e.target.value,10);
      save(LS.traits, traits);
      renderAvatar(traits);
    });
  }
  bindSlider("#empathy","empathy");
  bindSlider("#logic","logic");
  bindSlider("#play","playfulness");
  bindSlider("#conf","confidence");

  // --------- chat state ----------
  const chatEl = $("#chat");
  const msgs = load(LS.msgs, [{ role:"assistant", text:"Hello! I’m your personalizeable AI assistant. Adjust the sliders to change my appearance and conversation style." }]);
  const renderMsg = (m)=>`<div class="bubble ${m.role}">${m.text.replace(/</g,"&lt;")}</div>`;
  function repaint() {
    chatEl.innerHTML = msgs.map(renderMsg).join("");
    chatEl.scrollTop = chatEl.scrollHeight; // auto-scroll
  }
  repaint();

  // --------- traits → system message ----------
  function traitsSystemMessage(t){
    const empathyMap = ["terse","brisk","balanced","warm","caring","nurturing"][t.empathy];
    const logicMap = ["intuitive","casual","balanced","structured","analytical","formal"][t.logic];
    const playMap = ["grounded","plain","spry","colorful","playful","whimsical"][t.playfulness];
    const confMap = ["neutral","soft","balanced","assured","confident","upbeat"][t.confidence];

    return `Adopt this style:
- Tone: ${empathyMap}, ${confMap}
- Reasoning: ${logicMap}
- Flair: ${playMap}
Constraints:
- Keep answers concise.
- Match user vibe; don't overdo persona.
- If asked for steps, give one step at a time.`;
  }

  // --------- streaming chat via /api/chat ----------
  let streaming = false;
  let lastChunk = "";

  async function send(){
    if (streaming) return;
    const input = $("#prompt");
    const t = (input.value || "").trim();
    if (!t) return;

    input.value = "";
    msgs.push({ role:"user", text:t }, { role:"assistant", text:"" });
    save(LS.msgs, msgs); repaint();
    lastChunk = "";

    // Build history with system message derived from sliders
    const history = [
      { role: "system", content: traitsSystemMessage(traits) },
      ...msgs.map(m => ({ role: m.role, content: m.text }))
    ];

    try {
      streaming = true;
      const resp = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          stream: true,
          messages: history,
          temperature: 0.7
        })
      });
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      if (!resp.body) throw new Error("No response body");

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const events = buffer.split("\n\n");
        buffer = events.pop() || "";

        for (const ev of events) {
          if (!ev.startsWith("data:")) continue;
          const json = ev.slice(5).trim();
          if (!json || json === "[DONE]") continue;

          try {
            const pkt = JSON.parse(json);
            const delta = pkt?.choices?.[0]?.delta?.content || "";
            if (!delta) continue;
            if (delta === lastChunk) continue;
            lastChunk = delta;

            const last = msgs[msgs.length - 1];
            if (last && last.role === "assistant") last.text += delta;

            save(LS.msgs, msgs); repaint();
          } catch {}
        }
      }
    } catch (e) {
      const last = msgs[msgs.length - 1];
      if (last && last.role === "assistant") last.text = last.text || "⚠️ Error receiving response.";
      save(LS.msgs, msgs); repaint();
      console.error(e);
    } finally {
      streaming = false;
    }
  }

  $("#send").onclick = send;
  $("#prompt").addEventListener("keydown", (e)=>{
    if (e.key === "Enter" && !e.repeat) { e.preventDefault(); send(); }
  });
  $("#clear").onclick = ()=>{
    msgs.length = 0;
    msgs.push({ role:"assistant", text:"Hey 👋 I’m your personalizeable AI assistant. Try chatting with me!" });
    localStorage.removeItem(LS.msgs);
    repaint();
  };
</script>
</body>
</html>
